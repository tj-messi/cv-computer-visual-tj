# 配准

## 任务描述

### 平台

Fiji imagej下载

下载之后help行列update

然后Plugins->BigDataViewer->BigWarp

### 数据样例

    /date/h5ad/IF_S100B_contrast1_bright0.png

    /date/h5ad/B222.png

注意样例非常大，无法直接通过Fiji打开


### 下采预处理

先输出源数据的大小：

    from PIL import Image

    # 定义函数来检查图像分辨率
    def check_image_resolution(image_path):
        with Image.open(image_path) as img:
            width, height = img.size
            return width, height

    # 两张图片的路径
    image_path1 = '/date/h5ad/B222.png'  # 替换为图片1的路径
    image_path2 = '/date/h5ad/IF_S100B_contrast1_bright0.png'  # 替换为图片2的路径

    # 获取分辨率
    res1 = check_image_resolution(image_path1)
    res2 = check_image_resolution(image_path2)

    # 输出结果
    print(f"Image 1 resolution: {res1[0]}x{res1[1]}")
    print(f"Image 2 resolution: {res2[0]}x{res2[1]}")

输出

    Image 1 resolution: 19236x10840
    Image 2 resolution: 84960x48000

image1是可以被打开的但是image2不行。
所以将二者一起下采样缩小8倍数，然后再进行配准。

    from PIL import Image

    # 设置最大允许像素数
    Image.MAX_IMAGE_PIXELS = 20000000000  # 增加最大像素限制

    # 定义函数来检查图像分辨率
    def check_image_resolution(image_path):
        with Image.open(image_path) as img:
            width, height = img.size
            return width, height

    # 定义函数来下采样图像
    def downsample_image(image_path, scale_factor):
        with Image.open(image_path) as img:
            # 计算新尺寸
            new_width = img.width // scale_factor
            new_height = img.height // scale_factor
            # 下采样
            downsampled_img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            return downsampled_img

    # 两张图片的路径
    image_path1 = '/date/h5ad/B222.png'  # 替换为图片1的路径
    image_path2 = '/date/h5ad/IF_S100B_contrast1_bright0.png'  # 替换为图片2的路径

    # 获取分辨率
    res1 = check_image_resolution(image_path1)
    res2 = check_image_resolution(image_path2)

    # 输出原图分辨率
    print(f"Image 1 original resolution: {res1[0]}x{res1[1]}")
    print(f"Image 2 original resolution: {res2[0]}x{res2[1]}")

    # 下采样比例
    scale_factor = 8

    # 下采样图像
    downsampled_img1 = downsample_image(image_path1, scale_factor)
    downsampled_img2 = downsample_image(image_path2, scale_factor)

    # 获取下采样后的分辨率
    downsampled_res1 = downsampled_img1.size
    downsampled_res2 = downsampled_img2.size

    # 输出下采样后的分辨率
    print(f"Image 1 downsampled resolution: {downsampled_res1[0]}x{downsampled_res1[1]}")
    print(f"Image 2 downsampled resolution: {downsampled_res2[0]}x{downsampled_res2[1]}")

    # 可选择保存下采样后的图像
    downsampled_img1.save('/date/h5ad/B222_downsampled.png')
    downsampled_img2.save('/date/h5ad/IF_S100B_contrast1_bright0_downsampled.png')

输出

    Image 1 original resolution: 19236x10840
    Image 2 original resolution: 84960x48000
    Image 1 downsampled resolution: 2404x1355
    Image 2 downsampled resolution: 10620x6000

## 配准

从

![](https://cdn.jsdelivr.net/gh/tj-messi/picture/1748016821435.png)

到

![](https://cdn.jsdelivr.net/gh/tj-messi/picture/1748016846012.png)

降采样的配置要多标注几个点，因为可能有误差

    import cv2
    import numpy as np
    from PIL import Image
    import pandas as pd

    Image.MAX_IMAGE_PIXELS = 20000000000  # 增加最大像素限制

    # 读取配准表
    file_path = '/date/h5ad/landmarks3.csv'
    landmarks_df = pd.read_csv(file_path)

    # 提取配准点：前两列是图像1的坐标，后两列是图像2的坐标
    src_points = landmarks_df.iloc[:, 2:4].values  # 图像1的坐标
    dst_points = landmarks_df.iloc[:, 4:6].values  # 图像2的坐标

    # 获取下采样后的图像1和图像2的分辨率
    image_path1 = '/date/h5ad/B222_downsampled.png'  # 下采样后的图像1
    image_path2 = '/date/h5ad/IF_S100B_contrast1_bright0_downsampled.png'  # 下采样后的图像2

    # 读取图像并获取分辨率
    img1 = cv2.imread(image_path1)
    img2 = cv2.imread(image_path2)

    img1_height, img1_width = img1.shape[:2]
    img2_height, img2_width = img2.shape[:2]

    # 确保源点和目标点是浮动型
    src_points = np.float32(src_points)
    dst_points = np.float32(dst_points)

    # 计算仿射变换矩阵
    affine_matrix, _ = cv2.estimateAffine2D(src_points, dst_points)

    # 使用仿射变换矩阵将图像1配准到图像2
    aligned_img1 = cv2.warpAffine(img1, affine_matrix, (img2_width, img2_height))

    # 显示配准后的图像
    aligned_img1_pil = Image.fromarray(cv2.cvtColor(aligned_img1, cv2.COLOR_BGR2RGB))
    aligned_img1_pil.show()

    # 可选择保存配准后的图像
    cv2.imwrite('/date/h5ad/B222_downsampled_aligned.png', aligned_img1)

![](https://cdn.jsdelivr.net/gh/tj-messi/picture/f3ccbe71bfa917029bfaf1218f334ce.png)


原图配准，这俩图片是对应8倍关系的图片，直接把csv×8然后配准就行

    import numpy as np
    from PIL import Image
    import pandas as pd
    import cv2

    Image.MAX_IMAGE_PIXELS = 20000000000  # 增加最大像素限制

    # 读取配准表
    file_path = '/date/h5ad/landmarks3.csv'
    landmarks_df = pd.read_csv(file_path)

    # 提取配准点：前两列是图像1的坐标，后两列是图像2的坐标
    src_points = landmarks_df.iloc[:, 2:4].values  # 图像1的坐标
    dst_points = landmarks_df.iloc[:, 4:6].values  # 图像2的坐标

    # 设置放大比例（由于原图与下采样图像有8倍的差异）
    scale_factor = 8

    # 放大坐标
    src_points = src_points * scale_factor
    dst_points = dst_points * scale_factor

    # 使用 Pillow 打开图像1和图像2
    image_path1 = '/date/h5ad/B222.png'  # 原图像1
    image_path2 = '/date/h5ad/IF_S100B_contrast1_bright0.png'  # 原图像2

    img1_pil = Image.open(image_path1)
    img2_pil = Image.open(image_path2)

    # 将 PIL 图像转换为 NumPy 数组（适用于 OpenCV）
    img1 = np.array(img1_pil)
    img2 = np.array(img2_pil)

    img1_height, img1_width = img1.shape[:2]
    img2_height, img2_width = img2.shape[:2]

    # 确保源点和目标点是浮动型
    src_points = np.float32(src_points)
    dst_points = np.float32(dst_points)

    # 计算仿射变换矩阵
    affine_matrix, _ = cv2.estimateAffine2D(src_points, dst_points)

    # 使用仿射变换矩阵将图像1配准到图像2
    aligned_img1 = cv2.warpAffine(img1, affine_matrix, (img2_width, img2_height))

    # 显示配准后的图像
    aligned_img1_pil = Image.fromarray(cv2.cvtColor(aligned_img1, cv2.COLOR_BGR2RGB))
    aligned_img1_pil.show()

    # 可选择保存配准后的图像
    cv2.imwrite('/date/h5ad/B222_aligned.png', aligned_img1)

8倍csv配准坐标表之后就直接配准就可以

![](https://cdn.jsdelivr.net/gh/tj-messi/picture/1748018216896.png)

路径

    /date/h5ad/B222_aligned.png